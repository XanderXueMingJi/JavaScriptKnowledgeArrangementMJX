<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>第四种也是利用负的margin,待定考虑，不经常遇到 </title>
    <style>
       #left,
#right {
 float: left;
 margin: 0 0 0 -271px;
 width: 50%;
}
#main {
 width: 540px;
 float: left;
 background: green;
}
.inner {
 padding: 20px;
}
#left .inner,
#right .inner {
 margin: 0 0 0 271px;
 background: orange;
} 

/* 
这种方法如果在IE下会存在布局混乱的bug，你可以将div#right和div#left中的width值稍作修改： 

#left,
#right {
 float: left;
 margin: 0 0 0 -271px;
 width: 50%;
 *width: 49.9%;
}  */


    </style>
</head>
<body>

        <!-- 上面啰嗦完了常见的布局方法，接着进我们一起来看另外一种三列布局中间固定宽度，两边自适应宽度。对于我来说，这是一种很少碰到的布局方法 -->

        <!-- 　这种方法也是借助于负的margin来实现的，首先我们在中间列定好固定值，因为此值是不会在改变的，接着对其进行左浮动；那么关键地主是在左右边栏设置地方，这种方法是将其都进行50%的宽度设置，并加上中负的左边距，此负的左边距最理想的值是中间栏宽度的一半加上1px，比如说此例中是“540px/2+1”也就是说他们都有一个“margin-left: -271px”，这样一来，左右边栏内容无法正常显示，那是因为对他们进行了负的左边距操作，现在只需要在左右边栏的内层div.inner将其拉回来，就OK了 -->

    <div id="left">
        <div class="inner">this is left sidebar content</div>
       </div>
       <div id="main">
        <div class="inner">this is main content</div>
       </div>
       <div id="right">
        <div class="inner">this is right siderbar content</div>
       </div> 
 
</body>
</html>